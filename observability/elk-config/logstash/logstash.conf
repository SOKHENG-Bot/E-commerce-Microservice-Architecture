
input {
  # Input from Filebeat (container logs)
  beats {
    port => 5044
  }
  
  # Direct TCP input for services (optional)
  tcp {
    port => 5000
    codec => json_lines
  }
}

filter {
  # Parse JSON logs from microservices
  if [fields][service] {
    mutate {
      add_field => { "service_name" => "%{[fields][service]}" }
    }
  }

  # Extract service from container name if not present
  if ![service_name] and [container][name] {
    if [container][name] =~ /user[-_]service/ {
      mutate { add_field => { "service_name" => "user_service" } }
    } else if [container][name] =~ /product[-_]service/ {
      mutate { add_field => { "service_name" => "product_service" } }
    } else if [container][name] =~ /order[-_]service/ {
      mutate { add_field => { "service_name" => "order_service" } }
    } else if [container][name] =~ /notification[-_]service/ {
      mutate { add_field => { "service_name" => "notification_service" } }
    } else if [container][name] =~ /api[-_]gateway/ {
      mutate { add_field => { "service_name" => "api_gateway" } }
    }
  }

  # Parse JSON message content
  if [message] =~ /^{.*}$/ {
    json {
      source => "message"
    }
  }

  # Extract correlation ID for distributed tracing
  if [correlation_id] {
    mutate {
      add_field => { "trace_id" => "%{correlation_id}" }
    }
  }

  # Add timestamp parsing
  date {
    match => [ "timestamp", "ISO8601" ]
  }

  # Service-specific processing
  if [service_name] == "order_service" {
    if [operation_type] == "payment_processing" {
      mutate {
        add_tag => [ "payment", "critical" ]
      }
    }
    if [critical_failure] == true {
      mutate {
        add_tag => [ "critical_alert" ]
      }
    }
  }

  if [service_name] == "notification_service" {
    if [is_delivery_operation] == true {
      mutate {
        add_tag => [ "delivery", "notification" ]
      }
    }
    if [delivery_success] == false {
      mutate {
        add_tag => [ "delivery_failure" ]
      }
    }
  }

  if [service_name] == "product_service" {
    if [operation_type] == "search_operation" {
      mutate {
        add_tag => [ "search", "performance" ]
      }
    }
  }

  # Performance categorization
  if [processing_time] {
    if [processing_time] < 0.1 {
      mutate { add_field => { "performance_tier" => "excellent" } }
    } else if [processing_time] < 0.5 {
      mutate { add_field => { "performance_tier" => "good" } }
    } else if [processing_time] < 2.0 {
      mutate { add_field => { "performance_tier" => "acceptable" } }
    } else {
      mutate { add_field => { "performance_tier" => "slow" } }
      mutate { add_tag => [ "performance_issue" ] }
    }
  }
}

output {
  # Send to Elasticsearch with dynamic indexing
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "ecommerce-logs-%{service_name}-%{+YYYY.MM.dd}"
    
    # Use correlation_id as document ID for better tracing
    document_id => "%{correlation_id}-%{[@timestamp]}"
  }

  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}
