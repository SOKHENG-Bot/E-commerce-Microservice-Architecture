"""
This type stub file was generated by pyright.
"""

from collections.abc import Generator
from dataclasses import dataclass
from typing import Any, Optional, Union, final
from typing_extensions import Literal, Never
from aiokafka.util import NO_EXTENSIONS
from ._protocols import LegacyRecordBatchBuilderProtocol, LegacyRecordBatchProtocol, LegacyRecordMetadataProtocol, LegacyRecordProtocol
from ._types import CodecGzipT, CodecLz4T, CodecMaskT, CodecSnappyT, LegacyCompressionTypeT

NoneType = ...
class LegacyRecordBase:
    __slots__ = ...
    HEADER_STRUCT_V0 = ...
    HEADER_STRUCT_V1 = ...
    CRC_OFFSET = ...
    MAGIC_OFFSET = ...
    RECORD_OVERHEAD_V0 = ...
    RECORD_OVERHEAD_V1 = ...
    RECORD_OVERHEAD = ...
    KEY_OFFSET_V0 = ...
    KEY_OFFSET_V1 = ...
    VALUE_LENGTH = ...
    CODEC_MASK: CodecMaskT = ...
    CODEC_GZIP: CodecGzipT = ...
    CODEC_SNAPPY: CodecSnappyT = ...
    CODEC_LZ4: CodecLz4T = ...
    TIMESTAMP_TYPE_MASK = ...
    LOG_APPEND_TIME = ...
    CREATE_TIME = ...


@final
class _LegacyRecordBatchPy(LegacyRecordBase, LegacyRecordBatchProtocol):
    is_control_batch: bool = ...
    is_transactional: bool = ...
    producer_id: Optional[int] = ...
    def __init__(self, buffer: Union[bytes, bytearray, memoryview], magic: int) -> None:
        ...
    
    @property
    def next_offset(self) -> int:
        ...
    
    def validate_crc(self) -> bool:
        ...
    
    def __iter__(self) -> Generator[_LegacyRecordPy, None, None]:
        ...
    


@final
@dataclass(frozen=True)
class _LegacyRecordPy(LegacyRecordProtocol):
    __slots__ = ...
    offset: int
    timestamp: Optional[int]
    timestamp_type: Optional[Literal[0, 1]]
    key: Optional[bytes]
    value: Optional[bytes]
    crc: int
    @property
    def headers(self) -> list[Never]:
        ...
    
    @property
    def checksum(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


@final
class _LegacyRecordBatchBuilderPy(LegacyRecordBase, LegacyRecordBatchBuilderProtocol):
    _buffer: Optional[bytearray] = ...
    def __init__(self, magic: Literal[0, 1], compression_type: LegacyCompressionTypeT, batch_size: int) -> None:
        ...
    
    def append(self, offset: int, timestamp: Optional[int], key: Optional[bytes], value: Optional[bytes], headers: Any = ...) -> Optional[_LegacyRecordMetadataPy]:
        """Append message to batch."""
        ...
    
    def build(self) -> bytearray:
        """Compress batch to be ready for send"""
        ...
    
    def size(self) -> int:
        """Return current size of data written to buffer"""
        ...
    
    def size_in_bytes(self, offset: Any, timestamp: Any, key: Optional[bytes], value: Optional[bytes]) -> int:
        """Actual size of message to add"""
        ...
    
    @classmethod
    def record_overhead(cls, magic: int) -> int:
        ...
    


@final
class _LegacyRecordMetadataPy(LegacyRecordMetadataProtocol):
    __slots__ = ...
    def __init__(self, offset: int, crc: int, size: int, timestamp: int) -> None:
        ...
    
    @property
    def offset(self) -> int:
        ...
    
    @property
    def crc(self) -> int:
        ...
    
    @property
    def size(self) -> int:
        ...
    
    @property
    def timestamp(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


LegacyRecordBatchBuilder: type[LegacyRecordBatchBuilderProtocol]
LegacyRecordMetadata: type[LegacyRecordMetadataProtocol]
LegacyRecordBatch: type[LegacyRecordBatchProtocol]
LegacyRecord: type[LegacyRecordProtocol]
if NO_EXTENSIONS:
    LegacyRecordBatchBuilder = ...
    LegacyRecordMetadata = ...
    LegacyRecordBatch = ...
    LegacyRecord = ...
else:
    LegacyRecordBatchBuilder = ...
    LegacyRecordMetadata = ...
    LegacyRecordBatch = ...
    LegacyRecord = ...
